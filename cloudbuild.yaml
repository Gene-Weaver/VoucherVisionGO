steps:
  # Step 1: Check for changes in dependencies or submodules
  - name: 'gcr.io/cloud-builders/git'
    id: check-changes
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Ensure we have the full git history for diffing
        git fetch --unshallow || echo "Repository is not shallow."

        # Initialize the submodule
        git submodule update --init --recursive
        
        # --- LOGIC TO DETECT REAL CHANGES ---
        _DEPS_CHANGED="false"

        # 1. Check for changes in critical project files
        if git diff --name-only HEAD~1 HEAD | grep -q -E 'requirements.txt|Dockerfile|entrypoint.sh'; then
          echo "Critical dependency file changed."
          _DEPS_CHANGED="true"
        fi
        
        # 2. Check for changes WITHIN the submodule
        # Go into the submodule directory
        cd vouchervision_main
        
        # Get the current commit hash of the submodule checked out by the superproject
        CURRENT_SUB_COMMIT=$(git rev-parse HEAD)
        
        # Fetch the latest from the submodule's origin to make sure we have all remote info
        git fetch origin
        
        # Get the latest commit hash from the submodule's remote main/master branch
        # Try 'main' first, then fall back to 'master'
        LATEST_REMOTE_COMMIT=$(git rev-parse origin/main || git rev-parse origin/master)
        
        echo "Current submodule commit: $CURRENT_SUB_COMMIT"
        echo "Latest remote submodule commit: $LATEST_REMOTE_COMMIT"
        
        # Compare the hashes. If they are different, a rebuild is needed.
        if [ "$CURRENT_SUB_COMMIT" != "$LATEST_REMOTE_COMMIT" ]; then
          echo "Submodule 'vouchervision_main' has new commits."
          _DEPS_CHANGED="true"
        fi
        
        # Go back to the root workspace
        cd /workspace
        
        # Store the final result
        echo $_DEPS_CHANGED > /workspace/_deps_changed.txt
        echo "Final check - critical files changed: $_DEPS_CHANGED"


  # Step 2: Pull the latest image to use as cache (no changes needed)
  - name: 'gcr.io/cloud-builders/docker'
    id: pull-cache
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Try to pull the latest image to use as cache, ignore errors if it doesn't exist
        docker pull us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:latest || true

  # Step 3: Build with appropriate caching strategy based on whether deps changed
  - name: 'gcr.io/cloud-builders/docker'
    id: build
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Before building, ensure the submodule is updated to the absolute latest version
        # This is crucial because the check above only DETECTS a change, it doesn't APPLY it.
        git submodule update --init --recursive --remote
      
        _DEPS_CHANGED=$(cat /workspace/_deps_changed.txt)
        if [ "$_DEPS_CHANGED" = "true" ]; then
          echo "Rebuilding container from scratch due to critical file changes..."
          docker build --no-cache -t us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:${COMMIT_SHA} .
        else
          echo "Performing incremental build..."
          docker build --cache-from us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:latest -t us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:${COMMIT_SHA} .
        fi

  # Step 4: Push the container image to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:${COMMIT_SHA}']

  # Step 5: Tag the image as latest
  - name: 'gcr.io/cloud-builders/docker'
    args: ['tag', 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:${COMMIT_SHA}', 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:latest']
  
  # Step 6: Push the latest tag
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:latest']

  # Step 7: Deploy container image to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - 'vouchervision-go'
      - '--image'
      - 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:${COMMIT_SHA}'
      - '--region'
      - 'us-central1'
      - '--platform'
      - 'managed'
      - '--allow-unauthenticated'

# Store images in Artifact Registry
images:
  - 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:${COMMIT_SHA}'
  - 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:latest'

# Service account and logging configuration
serviceAccount: 'projects/${PROJECT_ID}/serviceAccounts/${_SERVICE_ACCOUNT_EMAIL}'
logsBucket: 'gs://${_BUCKET}'
options:
  logging: GCS_ONLY

# Define substitution variables
substitutions:
  _API_KEY: '' # Will be provided during deployment
  _SERVICE_ACCOUNT_EMAIL: '' # Service account email
  _BUCKET: '' # Logs bucket name