steps:
  # Step 1: Ensure submodules are fully updated. This brings the latest files into the workspace.
  - name: 'gcr.io/cloud-builders/git'
    id: update-submodules
    args: ['submodule', 'update', '--init', '--recursive', '--remote']

  # Step 2: (DEBUG) List the contents of the custom_prompts directory to verify they are present.
  - name: 'ubuntu'
    id: list-prompts
    args: ['ls', '-R', 'vouchervision_main/custom_prompts']

  # Step 3: Check if a full rebuild is needed and write the decision to a file.
  - name: 'gcr.io/cloud-builders/git'
    id: check-changes
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Ensure we have enough git history for a proper diff.
        git fetch --unshallow || echo "Repo is not shallow."
        
        # Check if critical files in the main repo OR the submodule directory itself have changed.
        # The 'if' statement checks the exit code of the 'grep' command.
        if git diff --name-only HEAD~1 HEAD | grep -q -E 'requirements.txt|Dockerfile|entrypoint.sh|vouchervision_main'; then
          echo "Critical file or submodule pointer changed. Forcing a full rebuild."
          # Write "true" to the decision file.
          echo "true" > /workspace/force_rebuild.txt
        else
          echo "No critical file changes detected. A cached build will be attempted."
          # Write "false" to the decision file.
          echo "false" > /workspace/force_rebuild.txt
        fi

  # Step 4: Build the container with the correct caching strategy.
  - name: 'gcr.io/cloud-builders/docker'
    id: build
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Read the decision from the previous step.
        _FORCE_REBUILD=$(cat /workspace/force_rebuild.txt)
        
        if [ "$_FORCE_REBUILD" = "true" ]; then
          echo "Building container from scratch (--no-cache)..."
          docker build --no-cache -t us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:${COMMIT_SHA} .
        else
          echo "Building container with cache from latest image..."
          docker pull us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:latest || true
          docker build --cache-from us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:latest -t us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:${COMMIT_SHA} .
        fi

  # Step 4: Push the container image to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:${COMMIT_SHA}']

  # Step 5: Tag the image as latest
  - name: 'gcr.io/cloud-builders/docker'
    args: ['tag', 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:${COMMIT_SHA}', 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:latest']
  
  # Step 6: Push the latest tag
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:latest']

  # Step 7: Deploy container image to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - 'vouchervision-go'
      - '--image'
      - 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:${COMMIT_SHA}'
      - '--region'
      - 'us-central1'
      - '--platform'
      - 'managed'
      - '--allow-unauthenticated'

# Store images in Artifact Registry
images:
  - 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:${COMMIT_SHA}'
  - 'us-central1-docker.pkg.dev/${PROJECT_ID}/cloud-run-source-deploy/vouchervisiongo/vouchervision-go:latest'

# Service account and logging configuration
serviceAccount: 'projects/${PROJECT_ID}/serviceAccounts/${_SERVICE_ACCOUNT_EMAIL}'
logsBucket: 'gs://${_BUCKET}'
options:
  logging: GCS_ONLY

# Define substitution variables
substitutions:
  _API_KEY: '' # Will be provided during deployment
  _SERVICE_ACCOUNT_EMAIL: '' # Service account email
  _BUCKET: '' # Logs bucket name